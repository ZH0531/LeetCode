<div lang="zh-CN" translate="no">

# LeetCode Java解法 每日更新

**我会在这里每日更新 LeetCode 的解题思路以及源码，欢迎大家提 issue (不喜勿喷)(虽然也没人看)**

## 📚 目录

- [哈希表](#哈希表)
- [双指针](#双指针)
- [滑动窗口](#滑动窗口)

---

## 哈希表

### [Problem 1 - 两数之和](src/LeetCode/HOT100/Problem1.java)

>作为 LeetCode Problem 1，无数人从这一题入门，还是很有纪念意义的。

>25年4月的时候，对未来一片迷茫的我，决定收起以前的散漫，开始系统性学习编程，学了一部分Java SE之后，偶然了解到 LeetCode，故事从此开始...

>25年5月第一次做的时候，用的是硬破解（如下），虽然时间复杂度很高也很低效，但是觉得还是挺有意思的，做出来很有成就感，可惜第二题就做不出来了，也看不懂题目...

**当时的代码**
```java
public int[] twoSum(int[] nums, int target){
    int[] result = new int[2]; // 返回数组，用来存下标的

    for (int i = 0; i < nums.length-1; i++){
        for(int j = i + 1; j < nums.length;j++){ //直接来一手双层循环 也是时间复杂度高的关键
            if(nums[i] + nums[j] == target){ 
                result[0] = i;
                result[1] = j;
            }
        }
    }
    return result;
}
```
>**25年10月，学成 Java Web 归来并且做过[单体项目](https://github.com/ZH0531/Z-Chat-Public)但是投简历仍然石沉大海的我，决定刷刷算法充实一下自己...
><br>于是打开了 LeetCode，开始每天都做几题，做了七八题之后，决定开始写这篇笔记来记录一下所思所想。**

**题目描述：**  
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

**题解：**

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> numMap = new HashMap<>(); // 哈希表
    for (int i = 0; i < nums.length; i++) { // 遍历数组（只需最多一轮）
        if (numMap.containsKey(target - nums[i])) { // 若存在另一位数字
            return new int[]{numMap.get(target - nums[i]), i}; // 构建数组并返回结果
        }
        numMap.put(nums[i], i); // 若不存在，则将当前数字和下标存入哈希表，以便下次查找
    }
    return null;
}
```

**解题思路：**

- 使用哈希表（HashMap）来存储数组元素和对应的下标，`key`是数组元素，`value`是下标
- 遍历数组，对于每个元素`nums[i]`，查找哈希表中是否存在`target - nums[i]`
  - 如果存在，直接返回两个下标，这就等于在已经遍历过的数组中找到了和为`target`的数
  - 如果不存在，将当前元素和下标存入哈希表，这样如果下次找到了`target - nums[i]`，就可以直接返回

💡 **为什么这样做？**

这样做的好处是对于数组 `nums`，我们只需要遍历一次，遍历过程中查找 `target - nums[i]` 的时候，由于使用哈希表，查找时间复杂度是 `O(1)`，也是典型的**空间换时间**策略。

📌 **哈希表的优势：** 哈希表非常适合快速查找，因为哈希表的原理是将值转换成哈希值来构建索引，这样下次查找该值的时候相当于直接使用索引，所以时间复杂度接近 `O(1)`。

**复杂度分析：**

- 时间复杂度：O(n)，只需要遍历一次数组
- 空间复杂度：O(n)，哈希表存储最多 n 个元素

**核心技巧：** 用空间换时间，将查找时间从 O(n) 降到 O(1)

---

### [Problem 49 - 字母异位词分组](src/LeetCode/HOT100/Problem49.java)

**题目描述：**  
给定一个字符串数组，请你将字母异位词组合在一起。字母异位词是由重新排列源单词的所有字母得到的一个新单词。

**示例：**
```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

解释：
- "bat" 无法通过重新排列形成其他单词
- "nat" 和 "tan" 是字母异位词
- "ate"、"eat" 和 "tea" 是字母异位词
```

**题解：**
```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>(); // 依然是哈希表
    for (String str : strs) { // 遍历数组
        char[] chars = str.toCharArray(); // 将遍历到的字符串转换为字符数组
        Arrays.sort(chars); // 对字符数组进行排序
        String key = new String(chars); // 将排序后的字符数组转换为字符串作为 key
        map.putIfAbsent(key, new ArrayList<>()); // 如果 key 不存在，则创建一个空的 ArrayList
        map.get(key).add(str); // 将当前字符串添加到对应的 key 的 ArrayList 中
    }
    return map.values().stream().toList(); // 将 map 的值转换为 List返回
}
```

**解题思路：**

- 使用哈希表（HashMap）进行分组
- 对每个字符串进行排序，排序后的字符串作为 key
- 所有异位词排序后会得到相同的 key，因此会被分到同一组
- 最后返回哈希表中所有的值

💡 **核心思想：**

为什么选择哈希表？因为哈希表的 **Key-Value 结构**非常适合这道题的分组需求！

📌 **关于字符排序：** Unicode 字符集的每个字符都有唯一的编码，因此我们可以将字符串中的字符进行排序。所有异位词排序后会得到相同的字符串，比如 "eat"、"tea"、"ate" 排序后都是 "aet"，这样就可以作为同一个 key 进行分组。

将排序过后的字符转换成字符串作为`key`的时候，我们需要将原字符串存入一个数组，也就是该`key`的`value`，以方便后续返回。

虽然需要对每个字符串进行排序，但整体效率仍然很高，时间复杂度为 `O(n × k log k)`

>本题应该是还有其他更高效的解法的，但是我这种解法效率也还行，代码比较简洁易懂

**复杂度分析：**

- 时间复杂度：O(n × k log k)，n 是字符串数组长度，k 是字符串平均长度
- 空间复杂度：O(n × k)，存储所有字符串

**核心技巧：** 寻找异位词的统一特征（排序后相同）作为哈希的 key

---

### [Problem 128 - 最长连续序列](src/LeetCode/HOT100/Problem128.java)

**题目描述：**  
给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。要求时间复杂度为 O(n)。

```
示例 1：

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：

输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
示例 3：

输入：nums = [1,0,1,2]
输出：3
```

**解题思路（方法一  排序）：** （不推荐）

**题解：**
```java
public int longestConsecutive(int[] nums) {
    if (nums.length == 0 || nums.length == 1) return nums.length; // 判断数组长度，0 或 1 直接返回
    Arrays.sort(nums); // 排序，让无序变成有序，这样数字就连续了...
    Set<Integer> numSet = new LinkedHashSet<>(); // 使用 LinkedHashSet 保持顺序和高效查询以及去重
    Arrays.stream(nums).forEach(numSet::add); // 将数组元素添加到 Set 中
    int count = 1; // 用于记录当前连续序列的长度
    int max = 1; // 用于记录最长连续序列的长度
    for (int num : numSet) {
        if (numSet.contains(num + 1)) count++; // 如果存在下一个数字，则长度加 1
        else {
            max = Math.max(max, count); // 如果中断，更新最长连续序列长度
            if (numSet.size() - max <= max) break; // 如果剩余元素不足以超过当前最大值，提前结束
            count = 1; // 重置当前长度
        }
    }
    return max;
}
```

- 先对数组排序，使用 LinkedHashSet 去重并保持顺序
- 遍历集合，检查是否存在连续数字
- 统计最长连续序列长度
- 添加剪枝优化：当剩余元素不足以超过当前最大值时提前结束

**复杂度分析：**

- 时间复杂度：O(n log n)，主要是排序
- 空间复杂度：O(n)

>好吧，这是我第一次做的时候的所使用的方法，用了这么一种有效但是很低效的方法，低效是因为在循环的时候遍历的整个数组，对每位数字都去计算由他开头的连续数字长度
><br>看了一下题解，不得不佩服天才的脑洞是真的大...把时间复杂度优化到极致，也就是以下做法 ↓ 

**解题思路（方法二 - 哈希优化）：** ⭐ 推荐

**题解：**

```java
public int longestConsecutive(int[] nums) {
    Set<Integer> numSet = new HashSet<>(); // 使用 HashSet 存储所有数字
    Arrays.stream(nums).forEach(numSet::add); // 将数组元素添加到 Set 中
    int count = 1; // 用于记录当前连续序列的长度
    int max = 0; // 用于记录最长连续序列的长度
    for (int num : numSet) {
        if (numSet.contains(num - 1)) continue; 
        // 上一句的意思是，找到连续数字的起点，如果不存在上一个数则代表该数是起点，才执行下面的代码，反之则跳过
        while (numSet.contains(num + 1)) { // 匹配下一个数字
            count++; // 统计长度
            num++; // 更新数字，下一轮匹配下下...个数字，一直循环，直到不满足循环条件退出
        }
        max = Math.max(count, max); // 当执行到这里，代表该数字是连续数字的终点，更新最长连续序列长度
        count = 1; // 重置当前长度，继续匹配下一个数字
        if (numSet.size() - max <= max) break; // 如果剩余元素不足以超过当前最大值，提前结束
    }
    return max;
}
```

- 使用 HashSet 存储所有数字，O(1) 查找
- 对于每个数字，只有当它是序列起点（不存在 `num-1`）时才开始统计
- 从起点开始向后查找连续数字，统计长度
- 这样每个数字最多被访问两次（一次检查起点，一次被计数）

**复杂度分析：**

- 时间复杂度：O(n)，满足题目要求
- 空间复杂度：O(n)

**核心技巧：** 使用哈希集合快速判断元素存在性，找到序列起点避免重复计算

>不得不说，想出这种解法的人是真的NBBBBBBB！看到这种解法我有种豁然开朗的感觉，还是想说NB！
><br>这种解法的关键在于，通过`num-1`来检测当前遍历到的数字是不是连续数字的起点，如果不是就不要浪费时间，直接下一个！
><br>当遍历到的数字在集合里找不到`num-1`，则说明当前数字是连续数字的起点，才开始统计长度
><br>我在最后还是加上了截断优化，如果剩余元素不足以超过当前最大值，提前结束，避免无用功
><br>另外想说的是，所有与优化查询时间有关的，都可以用哈希表，时间复杂度为 `O(1)`，发明哈希表的也是个天才！

---

## 双指针

### [Problem 11 - 盛最多水的容器](src/LeetCode/HOT100/Problem11.java)

**题目描述：**  
给定一个长度为 n 的整数数组 `height`，有 n 条垂线，找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

**解题思路：**

- 使用对撞型双指针，左指针从最左端开始，右指针从最右端开始
- 计算当前容器的面积：`area = min(height[left], height[right]) × (right - left)`
- 移动较短的那一边的指针，因为移动较长边不可能增加面积
- 持续更新最大面积

**复杂度分析：**

- 时间复杂度：O(n)，只需要遍历一次数组
- 空间复杂度：O(1)，只使用常数额外空间

**核心技巧：** 贪心思想 + 双指针，每次移动较短边才可能找到更大面积

---

### [Problem 15 - 三数之和](src/LeetCode/HOT100/Problem15.java)

**题目描述：**  
给你一个整数数组 `nums`，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k`，同时还满足
`nums[i] + nums[j] + nums[k] == 0`。

**解题思路：**

1. 先对数组进行排序
2. 固定一个数 `nums[i]`，然后使用双指针在剩余数组中寻找两个数，使得三数之和为 0
3. 通过跳过重复元素来去重，避免重复的三元组

**复杂度分析：**

- 时间复杂度：O(n²)，排序 O(n log n)，外层循环 O(n)，内层双指针 O(n)
- 空间复杂度：O(log n)，排序需要的栈空间

**核心技巧：** 排序 + 双指针，将三数之和转化为两数之和问题

---

### [Problem 42 - 接雨水](src/LeetCode/HOT100/Problem42.java)

**题目描述：**  
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**解题思路（方法一 - 按层统计）：** [查看代码](src/LeetCode/HOT100/Problem42.java)

- 从下到上按层统计雨水
- 每一层找到最左边和最右边的柱子
- 统计中间低于当前层高度的位置，累加雨水量

**复杂度分析：**

- 时间复杂度：O(n × h)，n 是数组长度，h 是最大高度（较慢，不推荐）
- 空间复杂度：O(1)

**解题思路（方法二 - 双指针优化）：** [查看代码](src/LeetCode/HOT100/Problem42_1.java) ⭐ 推荐

- 使用对撞型双指针，分别维护左右两边的最大高度 `leftMax` 和 `rightMax`
- 关键洞察：较矮一侧的水位完全由该侧的最大高度决定
- 每次移动较矮的一侧指针，累加可接的雨水：`max - height[i]`

**复杂度分析：**

- 时间复杂度：O(n)，只需遍历一次
- 空间复杂度：O(1)

**核心技巧：** 双指针 + 贪心，利用"木桶效应"原理，较矮侧决定水位

---

### [Problem 283 - 移动零](src/LeetCode/HOT100/Problem283.java)

**题目描述：**  
给定一个数组 `nums`，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。必须在不复制数组的情况下原地对数组进行操作。

**解题思路：**

- 使用快慢指针法，慢指针 `index` 记录非零元素应该放置的位置
- 快指针遍历数组，遇到非零元素就将其放到慢指针位置，然后慢指针后移
- 遍历结束后，将 `index` 后面的所有位置填充为 0

**复杂度分析：**

- 时间复杂度：O(n)，只需遍历一次数组
- 空间复杂度：O(1)，原地操作

**核心技巧：** 快慢指针，慢指针维护"已处理区域"的边界

---

## 滑动窗口

### [Problem 3 - 无重复字符的最长子串](src/LeetCode/HOT100/Problem3.java)

**题目描述：**  
给定一个字符串 `s`，请你找出其中不含有重复字符的最长子串的长度。

**解题思路（方法一 - 基础滑动窗口）：** [查看代码](src/LeetCode/HOT100/Problem3.java)

- 使用滑动窗口 + HashSet 来记录当前窗口内的字符
- 使用两个指针 `left` 和 `right` 构成滑动窗口
- 对于每个 `left` 位置，向右扩展 `right`，直到遇到重复字符
- 记录每个窗口的长度，更新最大值
- 移动 `left` 指针，清空 HashSet，重新开始

**复杂度分析：**

- 时间复杂度：O(n²)，外层循环 O(n)，内层窗口扩展 O(n)
- 空间复杂度：O(min(n, m))，m 是字符集大小

**解题思路（方法二 - 优化滑动窗口）：** [查看代码](src/LeetCode/HOT100/Problem3_1.java) ⭐ 推荐

- 使用 HashMap 记录每个字符最后出现的位置
- 右指针 `right` 不断向右扩展
- 当遇到重复字符时，左指针 `left` 直接跳转到重复字符上次出现位置的下一位
- 关键：`left = max(left, map.get(c) + 1)`，确保左指针只能右移
- 每次更新最大长度和字符位置

**复杂度分析：**

- 时间复杂度：O(n)，右指针遍历一次字符串
- 空间复杂度：O(min(n, m))，m 是字符集大小

**核心技巧：**

- 滑动窗口维护"无重复"的约束条件
- 使用 HashMap 记录位置，实现窗口的快速滑动（跳跃）

---

## 🏷️ 算法分类总览

| 算法类型 | 题目编号            | 题目数量 |
|------|-----------------|------|
| 哈希表  | 1, 49, 128      | 3 题  |
| 双指针  | 11, 15, 42, 283 | 4 题  |
| 滑动窗口 | 3               | 1 题  |

## 💡 算法技巧总结

### 哈希表使用场景

- ✅ 需要 O(1) 快速查找
- ✅ 去重、分组、计数
- ✅ 两数之和类问题
- ✅ 字符串匹配、异位词

### 双指针使用场景

- ✅ 有序数组查找
- ✅ 对撞型：从两端向中间逼近
- ✅ 快慢型：原地修改数组
- ✅ 区间问题、面积/容量问题

### 滑动窗口使用场景

- ✅ 子串/子数组问题
- ✅ 连续元素的最值
- ✅ 固定/可变长度的窗口
- ✅ 满足某种条件的最长/最短

---

<div align="center">
  
Made with ❤️ by ZH0531

</div>

</div>
<!-- End of lang="zh-CN" -->
