# LeetCode Java解法 每日更新

---

我会在这里存放 LeetCode 的解题思路以及源码，欢迎大家提 issue (不喜勿喷)

## 📚 目录

- [哈希表](#哈希表)
- [双指针](#双指针)
- [滑动窗口](#滑动窗口)

---

## 哈希表

### [Problem 1 - 两数之和](src/LeetCode/HOT100/Problem1.java)

**题目描述：**  
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

**解题思路：**
- 使用哈希表（HashMap）来存储数组元素和对应的下标
- 遍历数组，对于每个元素 `nums[i]`，查找哈希表中是否存在 `target - nums[i]`
- 如果存在，直接返回两个下标
- 如果不存在，将当前元素和下标存入哈希表

**复杂度分析：**
- 时间复杂度：O(n)，只需要遍历一次数组
- 空间复杂度：O(n)，哈希表存储最多 n 个元素

**核心技巧：** 用空间换时间，将查找时间从 O(n) 降到 O(1)

---

### [Problem 49 - 字母异位词分组](src/LeetCode/HOT100/Problem49.java)

**题目描述：**  
给你一个字符串数组，请你将字母异位词组合在一起。字母异位词是由重新排列源单词的所有字母得到的一个新单词。

**解题思路：**
- 使用哈希表（HashMap）进行分组
- 对每个字符串进行排序，排序后的字符串作为 key
- 所有异位词排序后会得到相同的 key，因此会被分到同一组
- 最后返回哈希表中所有的值

**复杂度分析：**
- 时间复杂度：O(n × k log k)，n 是字符串数组长度，k 是字符串平均长度
- 空间复杂度：O(n × k)，存储所有字符串

**核心技巧：** 寻找异位词的统一特征（排序后相同）作为哈希的 key

---

### [Problem 128 - 最长连续序列](src/LeetCode/HOT100/Problem128.java)

**题目描述：**  
给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。要求时间复杂度为 O(n)。

**解题思路（方法一 - 排序）：** [查看代码](src/LeetCode/HOT100/Problem128.java)
- 先对数组排序，使用 LinkedHashSet 去重并保持顺序
- 遍历集合，检查是否存在连续数字
- 统计最长连续序列长度
- 添加剪枝优化：当剩余元素不足以超过当前最大值时提前结束

**复杂度分析：**
- 时间复杂度：O(n log n)，主要是排序
- 空间复杂度：O(n)

**解题思路（方法二 - 哈希优化）：** [查看代码](src/LeetCode/HOT100/Problem128_1.java) ⭐ 推荐
- 使用 HashSet 存储所有数字，O(1) 查找
- 对于每个数字，只有当它是序列起点（不存在 `num-1`）时才开始统计
- 从起点开始向后查找连续数字，统计长度
- 这样每个数字最多被访问两次（一次检查起点，一次被计数）

**复杂度分析：**
- 时间复杂度：O(n)，满足题目要求
- 空间复杂度：O(n)

**核心技巧：** 使用哈希集合快速判断元素存在性，找到序列起点避免重复计算

---

## 双指针

### [Problem 11 - 盛最多水的容器](src/LeetCode/HOT100/Problem11.java)

**题目描述：**  
给定一个长度为 n 的整数数组 `height`，有 n 条垂线，找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

**解题思路：**
- 使用对撞型双指针，左指针从最左端开始，右指针从最右端开始
- 计算当前容器的面积：`area = min(height[left], height[right]) × (right - left)`
- 移动较短的那一边的指针，因为移动较长边不可能增加面积
- 持续更新最大面积

**复杂度分析：**
- 时间复杂度：O(n)，只需要遍历一次数组
- 空间复杂度：O(1)，只使用常数额外空间

**核心技巧：** 贪心思想 + 双指针，每次移动较短边才可能找到更大面积

---

### [Problem 15 - 三数之和](src/LeetCode/HOT100/Problem15.java)

**题目描述：**  
给你一个整数数组 `nums`，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k`，同时还满足 `nums[i] + nums[j] + nums[k] == 0`。

**解题思路：**
1. 先对数组进行排序
2. 固定一个数 `nums[i]`，然后使用双指针在剩余数组中寻找两个数，使得三数之和为 0
3. 通过跳过重复元素来去重，避免重复的三元组

**复杂度分析：**
- 时间复杂度：O(n²)，排序 O(n log n)，外层循环 O(n)，内层双指针 O(n)
- 空间复杂度：O(log n)，排序需要的栈空间

**核心技巧：** 排序 + 双指针，将三数之和转化为两数之和问题

---

### [Problem 42 - 接雨水](src/LeetCode/HOT100/Problem42.java)

**题目描述：**  
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**解题思路（方法一 - 按层统计）：** [查看代码](src/LeetCode/HOT100/Problem42.java)
- 从下到上按层统计雨水
- 每一层找到最左边和最右边的柱子
- 统计中间低于当前层高度的位置，累加雨水量

**复杂度分析：**
- 时间复杂度：O(n × h)，n 是数组长度，h 是最大高度（较慢，不推荐）
- 空间复杂度：O(1)

**解题思路（方法二 - 双指针优化）：** [查看代码](src/LeetCode/HOT100/Problem42_1.java) ⭐ 推荐
- 使用对撞型双指针，分别维护左右两边的最大高度 `leftMax` 和 `rightMax`
- 关键洞察：较矮一侧的水位完全由该侧的最大高度决定
- 每次移动较矮的一侧指针，累加可接的雨水：`max - height[i]`

**复杂度分析：**
- 时间复杂度：O(n)，只需遍历一次
- 空间复杂度：O(1)

**核心技巧：** 双指针 + 贪心，利用"木桶效应"原理，较矮侧决定水位

---

### [Problem 283 - 移动零](src/LeetCode/HOT100/Problem283.java)

**题目描述：**  
给定一个数组 `nums`，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。必须在不复制数组的情况下原地对数组进行操作。

**解题思路：**
- 使用快慢指针法，慢指针 `index` 记录非零元素应该放置的位置
- 快指针遍历数组，遇到非零元素就将其放到慢指针位置，然后慢指针后移
- 遍历结束后，将 `index` 后面的所有位置填充为 0

**复杂度分析：**
- 时间复杂度：O(n)，只需遍历一次数组
- 空间复杂度：O(1)，原地操作

**核心技巧：** 快慢指针，慢指针维护"已处理区域"的边界

---

## 滑动窗口

### [Problem 3 - 无重复字符的最长子串](src/LeetCode/HOT100/Problem3.java)

**题目描述：**  
给定一个字符串 `s`，请你找出其中不含有重复字符的最长子串的长度。

**解题思路（方法一 - 基础滑动窗口）：** [查看代码](src/LeetCode/HOT100/Problem3.java)
- 使用滑动窗口 + HashSet 来记录当前窗口内的字符
- 使用两个指针 `left` 和 `right` 构成滑动窗口
- 对于每个 `left` 位置，向右扩展 `right`，直到遇到重复字符
- 记录每个窗口的长度，更新最大值
- 移动 `left` 指针，清空 HashSet，重新开始

**复杂度分析：**
- 时间复杂度：O(n²)，外层循环 O(n)，内层窗口扩展 O(n)
- 空间复杂度：O(min(n, m))，m 是字符集大小

**解题思路（方法二 - 优化滑动窗口）：** [查看代码](src/LeetCode/HOT100/Problem3_1.java) ⭐ 推荐
- 使用 HashMap 记录每个字符最后出现的位置
- 右指针 `right` 不断向右扩展
- 当遇到重复字符时，左指针 `left` 直接跳转到重复字符上次出现位置的下一位
- 关键：`left = max(left, map.get(c) + 1)`，确保左指针只能右移
- 每次更新最大长度和字符位置

**复杂度分析：**
- 时间复杂度：O(n)，右指针遍历一次字符串
- 空间复杂度：O(min(n, m))，m 是字符集大小

**核心技巧：** 
- 滑动窗口维护"无重复"的约束条件
- 使用 HashMap 记录位置，实现窗口的快速滑动（跳跃）

---

## 🏷️ 算法分类总览

| 算法类型 | 题目编号 | 题目数量 |
|---------|---------|---------|
| 哈希表 | 1, 49, 128 | 3 题 |
| 双指针 | 11, 15, 42, 283 | 4 题 |
| 滑动窗口 | 3 | 1 题 |

## 💡 算法技巧总结

### 哈希表使用场景
- ✅ 需要 O(1) 快速查找
- ✅ 去重、分组、计数
- ✅ 两数之和类问题
- ✅ 字符串匹配、异位词

### 双指针使用场景
- ✅ 有序数组查找
- ✅ 对撞型：从两端向中间逼近
- ✅ 快慢型：原地修改数组
- ✅ 区间问题、面积/容量问题

### 滑动窗口使用场景
- ✅ 子串/子数组问题
- ✅ 连续元素的最值
- ✅ 固定/可变长度的窗口
- ✅ 满足某种条件的最长/最短

---



<p align="center">Made with ❤ by ZH0531
